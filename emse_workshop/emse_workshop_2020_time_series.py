# -*- coding: utf-8 -*-
"""Copie de EMSE - Workshop 2020 - Time Series.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mGVSIgkmTACjDdBx0ewzxJJufj_8fc2Q
"""

!pip install gdown
!gdown https://drive.google.com/uc?id=16fNBGPSKQGOX0-5Cz0P8fLRlPMEU2HpS
!unzip -qo 'TS_data.zip'

from os.path import join
import pandas
import numpy as np


bl = (None, {'Bill load (year 1) | (kWh)'})[1]
ts_label = 'Time stamp'
months = dict({'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
               'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11})
targets = ['System power generated | (kW)', 'Electricity load (year 1) | (kW)']


def time_stamp_numpy(ts):
    """ Time Stamp to 3 uint8 month, day, hour
    # Arguments
        :param ts: pandas series, time stamp
    # Returns
        :return nts: numpy array, month (0-11), day (0-30), hour (0-23), day of week (0-6)
    """
    nts = np.zeros((ts.shape[0], 4), dtype=np.uint8)
    for i, t in enumerate(ts):
        idx = t.find(' ')
        assert idx != -1, 'No space in "%s"' % ts_label
        assert t[:idx] in months, 'Unknown month: %s' % t[:idx]
        nts[i, 0], start = months[t[:idx]], idx + 1
        idx = t.find(', ', start)
        assert idx != -1, 'No comma followed by space in "%s"' % ts_label
        nts[i, 1], start = int(t[start:idx]) - 1, idx + 2
        nts[i, 2] = (int(t[start:start + 2]) % 12) + (12 if t.endswith(' pm') else 0)
        nts[i, 3] = i % 7
    return nts


def select_columns(df, targets, blc=bl):
    """ Select columns with variance and not blacklisted. Position of targets.
    # Arguments
        :param df: pandas dataframe, data
        :param targets: list of str, targets column's names
        :param blc: None / Set of str, column's names to skip (time stamp automatically added)
    # Returns
        :return: numpy array, values of selected columns
        :return t_pos: numpy array, targets positions
    """
    blc, res, t_pos = (set() if blc is None else blc) | {ts_label}, list(), -np.ones(len(targets), dtype=np.int64)
    for i, c in enumerate(df.columns):
        if c in blc:
            print('{:2d} Blacklisted %s'.format(i, c))
            continue
        uv = df[c].value_counts().to_dict()
        if len(uv) < 2:
            print('{:2d} No variance in {:s}'.format(i, c))
            continue
        th = max(list(uv.values())) / df.shape[0]
        if th > .95:
            print('{:2d} Single value > 95% of {:s}'.format(i, c))
            continue
        to_prt = '{:2d} {:<100s} {:<15s} {:.3f}'.format(i, c, str(df[c].dtype), th)
        if c in targets:
            t_idx = targets.index(c)
            t_pos[t_idx] = len(res)
            to_prt = '{:s} *Target {:d}*'.format(to_prt, t_idx)
        res.append(c)
        print(to_prt)
    return df[res].values, t_pos


def split_indexing(nbs, chunk, w=1, step=1, pred=0, pct_val=.2, pct_test=.2, seed=13120):
    """ Split data into train, valid and test. Return indexes for start of windows and index for statistics.
    # Arguments
        :param nbs: int, number of samples in full data set
        :param chunk: int, size of a data chunk
        :param w: int, time series window
        :param step: int, time series step
        :param pred: int, prediction look ahead
        :param pct_val: float, percentage of data used for validation
        :param pct_test: float, percentage if data used for testing
        :param seed: int, RNG seed
    # Returns
        :return ds: dict, dataset
            'train': numpy array, indexes of train data set
            'valid': numpy array, indexes of valid data set
            'test': numpy array, indexes of test data set
        :return idx_s, numpy array, indexes of train data set for statistics
    """
    np.random.seed(seed)
    p_max = nbs - w + 1 - pred
    nbc = p_max // chunk
    nb_val, nb_test = int(np.ceil(nbc * pct_val)), int(np.ceil(nbc * pct_test))
    perm = np.random.permutation(nbc)
    i_te, i_va, i_tr = set(perm[:nb_test]), set(perm[nb_test:nb_test + nb_val]), set(perm[nb_test + nb_val:])
    ds, idx_s = dict({'train': None, 'valid': None, 'test': None}), None
    for i in range(nbc):
        start = i * chunk
        if start >= p_max:
            break
        nxt_c = i + 1
        if i in i_te:
            ds_k, nxt_in = 'test', (nxt_c < nbc) and (nxt_c in i_te)
        elif i in i_va:
            ds_k, nxt_in = 'valid', (nxt_c < nbc) and (nxt_c in i_va)
        else:
            ds_k, nxt_in = 'train', (nxt_c < nbc) and (nxt_c in i_tr)
        end_range = min(p_max, nxt_c * chunk - (0 if nxt_in else w - 1))
        to_add = np.arange(start, end_range, step)
        ds[ds_k] = to_add if ds[ds_k] is None else np.concatenate((ds[ds_k], to_add))
        if ds == 'train':
            to_add = np.arange(start, end_range)
            idx_s = to_add if idx_s is None else np.concatenate((idx_s, to_add))
    return ds, idx_s


def load_select(data_file_name, targets, w, pred, chunk):
    """ * Load data file
        * Format time stamp
        * Select columns and find targets positions
        * split data set
    # Arguments
        :param data_file_name: str, data file name (with path)
        :param targets: list of str, targets names
        :param w: int, time series window
        :param pred: int, prediction look ahead
    # Returns
        :return nts: numpy array, time stamp
        :return data: numpy array, data selected and standardized
        :return idx: dict, data set indexes
        :return t_pos: numpy array, targets positions
        :return idx_s: dict, data set indexes of training samples
    """
    df = pandas.read_csv(data_file_name)
    nts = time_stamp_numpy(df[ts_label])
    data, t_pos = select_columns(df, targets)
    idx, idx_s = split_indexing(data.shape[0], chunk, w=w, pred=pred)
    return nts, data, idx, t_pos, idx_s

from os.path import join
from pickle import dump as pidump, load as piload
from csv import DictReader
from matplotlib import pyplot as plt
import numpy as np
import tensorflow as tf


model_path = join('.')


def get_stat(data, idx_s):
    """ Compute mean and standard deviation for each features in training set
    # Arguments
        :param data: numpy array, full data set
        :param idx_s: numpy arrat, training index for statistics
    # Returns
        :return stat: dict, statistics on training data
            'mean': numpy array, mean of each features
            'std': numpy array, standard deviation of each features
    """
    stat = dict({'mean': np.mean(data[idx_s], axis=1), 'std': np.std(data[idx_s], axis=1, ddof=1)})
    return stat


def apply_stat(data, stat):
    """ Standardize full data set
    # Arguments
        :param data: numpy array, full data set
        :param stat: dict, mean and std of training data
    # Returns
        :return: numpy array, standardized data
    """
    return (data - stat['mean']) / stat['std']


def load_select_standardize(data_file_name, targets, w, pred, chunk=12):
    """ * Load data file
        * Format time stamp
        * Select columns and find targets positions
        * split data set
        * Compute and apply statistics (standardization)
    # Arguments
        :param data_file_name: str, data file name (with path)
        :param targets: list of str, targets names
        :param w: int, time series window
        :param pred: int, prediction look ahead
        :param chunk: int, atomic size for splitting train, valid & test data
    # Returns
        :return nts: numpy array, time stamp
        :return data: numpy array, data selected and standardized
        :return idx: dict, data set indexes
        :return t_pos: numpy array, targets positions
    """
    nts, data, idx, t_pos, idx_s = load_select(data_file_name, targets, w, pred, chunk)
    stat = get_stat(data, idx_s)
    data = apply_stat(data, stat)
    return nts, data, idx, t_pos


def add_ts(data, nts, idx):
    """ Add time stamp data at the end of full data set
    # Arguments
        :param data: numpy array, data
        :param nts: numpy array, time stamp data
        :param idx: int, index of time stamp data to add
    # Returns
        :return: numpy, array, data augmented
    """
    id_m = np.eye(nts[:, idx].max() + 1)
    return np.concatenate((data, id_m[nts[:, idx]]), axis=-1)


def plot_log(filename, show=None):
    """ Plot  training / validation learning curve
    # Arguments
        :param filename: str, csv log file name
        :param show: None / str, show graph if none or save to show.png
    """
    keys, values, idx = list(), list(), None
    with open(filename, 'r') as f:
        reader = DictReader(f)
        for row in reader:
            if len(keys) == 0:
                for key, value in row.items():
                    keys.append(key)
                    values.append(float(value))
                idx = keys.index('epoch')
                continue
            for _, value in row.items():
                values.append(float(value))
        values = np.reshape(values, newshape=(-1, len(keys)))
        values[:, idx] += 1
    fig = plt.figure(figsize=(6, 9))
    fig.subplots_adjust(top=0.95, bottom=0.05, right=0.95)
    fig.add_subplot(211)
    for i, key in enumerate(keys):
        if key.find('loss') >= 0:   # and not key.find('val') >= 0:
            plt.plot(values[:, idx], values[:, i], label=key)
    plt.legend()
    plt.title('Training and validation loss')
    fig.add_subplot(212)
    for i, key in enumerate(keys):
        if key.find('mean') >= 0:
            plt.plot(values[:, idx], values[:, i], label=key)
    plt.legend()
    plt.title('Training and validation error')
    if show is not None:
        fig.savefig('%s.png' % show)
        plt.close(fig)
    else:
        plt.show()

def data_generator(data, idx, target, w, pred, noise=None, sn=None, batch=32):
    """ Generator for training / validating
    # Arguments
        :param data: numpy array, full data set
        :param idx: numpy array, index of samples
        :param target: int, target position in data set
        :param w: int, time series window
        :param pred: int, prediction look ahead
        :param noise: None / float, noise factor
        :param sn: None / int, noise separation position
        :param batch: int, batch
    # Yields
        :return bd: numpy array, data
        :return obj: numpy array, target
    """
    nbs, nbf, p_batch = idx.shape[0], data.shape[1] - 1, 0
    bd, obj, p_idx = np.zeros((batch, w, nbf), dtype=data.dtype), np.zeros(batch, dtype=data.dtype), nbs
    no_noise = np.zeros((batch, w, nbf - sn), dtype=data.dtype)
    while True:
        if p_idx == nbs:
            perm, p_idx = np.random.permutation(nbs), 0
        s = idx[perm[p_idx]]
        p_idx += 1
        bd[p_batch] = np.concatenate((data[s:s + w, :target], data[s:s + w, target + 1:]), axis=-1)
        obj[p_batch] = data[s + w - 1 + pred, target]
        p_batch += 1
        if p_batch == batch:
            if noise is not None:
                bd += np.concatenate((np.random.normal(scale=noise, size=(batch, w, sn)), no_noise), axis=-1)
            yield bd, obj
            p_batch = 0


def train_model(w, pred, name, data, idx, target, epoch=100, lr=1e-6, noise=None, sn=None, batch=16):
    """ Compile train and save log image for a model
    # Arguments
        :param w: int, window (time dimension)
        :param pred: int, prediction look ahead
        :param name: srt, name
        :param data: numpy array, full data set
        :param idx: dict, indexes of train / valid / test data set
        :param target: int, target position in data set
        :param epoch: int, epoch
        :param lr: float, learning rate
        :param noise: None / float, noise factor
        :param sn: None / int, noise separation position
        :param batch: int, batch (train & valid)
    """
    model = create_model(w, data.shape[1] - 1)
    model.compile(optimizer=tf.keras.optimizers.RMSprop(lr=lr),
                  loss=tf.keras.losses.mse, metrics=['mape'])
    model.summary()
    g_tr = data_generator(data, idx['train'], target, w=w,
                          pred=pred, noise=noise, sn=sn, batch=batch)
    s_tr = int(np.ceil(idx['train'].shape[0] / batch))
    g_va = data_generator(data, idx['valid'], target, w=w,
                          pred=pred, noise=noise, sn=sn, batch=batch)
    s_va = int(np.ceil(idx['valid'].shape[0] / batch))
    fn = join(model_path, name)
    cb = list()
    cb.append(tf.keras.callbacks.CSVLogger('%s.log' % fn))
    cb.append(tf.keras.callbacks.ModelCheckpoint('%s.loss' % fn,
                                                 monitor='val_loss',
                                                 mode='min',
                                                 save_best_only=True))
    cb.append(tf.keras.callbacks.ModelCheckpoint('%s.last' % fn, save_freq=1))
    model.fit_generator(generator=g_tr, steps_per_epoch=s_tr,
                        validation_data=g_va, validation_steps=s_va,
                        epochs=epoch, verbose=1, callbacks=cb,
                        max_queue_size=10, use_multiprocessing=True)
    plot_log('%s.log' % fn, show='%s_log' % fn)


def full_predictions(m, data, ds, target, w, batch):
    """ Predict on data for model m
    # Arguments
        :param m: keras model
        :param data: numpy array, full data set
        :param ds: numpy array, indexes
        :param target: int, position of target in data set
        :param w: int, window (time dimension)
        :param batch: int, batch
    # Returns
        :return preds: numpy array, predictions
    """
    last, bd, p_b, preds = ds.shape[0] - 1, np.zeros((batch, w, data.shape[1] - 1)), 0, None
    for i, s in enumerate(ds):
        bd[p_b] = np.concatenate((data[s:s + w, :target], data[s:s + w, target + 1:]), axis=-1)
        p_b += 1
        if p_b == batch or i == last:
            p = m.predict_on_batch(bd[:p_b]).squeeze()
            preds = p if preds is None else np.concatenate((preds, p), axis=0)
            p_b = 0
    return preds


def pred_grap_nn(models, data, idx, target, w, pred, batch=128, t_idx='test', step=200):
    """ Predict and graph a list of models (on exact same data) and grand truth
    # Arguments
        :param models: list of str, file names of models to load and predict with
        :param data: numpy array, full data set (ready for predictions)
        :param idx: dict, indexes for train, valid & test data set
        :param target: int, psition of target in data set
        :param w: int, time series window (time dimension)
        :param pred: int, prediction look ahaed
        :param batch: int, batch
        :param t_idx: str,
    """
    predictions, grand_truth = list(), data[idx[t_idx] + w - 1 + pred, target]
    for name in models:
        print('Predict for %s' % name)
        fn = join(model_path, '%s.loss' % name)
        m = tf.keras.models.load_model(fn)
        predictions.append(full_predictions(m, data, idx[t_idx], target, w, batch))
    graph_comparison(predictions, data, idx, target, w, pred, t_idx=t_idx, step=step)


def graph_comparison(predictions, data, idx, target, w, pred, t_idx, step):
    """ Graph a list of models predictions (on exact same data) and grand truth
    # Arguments
        :param predictions: list of numpy array, predictions for all models to be graphed
        :param data: numpy array, full data set (ready for predictions)
        :param idx: dict, indexes for train, valid & test data set
        :param target: int, psition of target in data set
        :param w: int, time series window (time dimension)
        :param pred: int, prediction look ahaed
        :param batch: int, batch
        :param t_idx: str,
    """
    grand_truth, pos, nbg = data[idx[t_idx] + w - 1 + pred, target], 0, 0
    while pos < grand_truth.shape[0]:
        stop = pos + step
        if grand_truth.shape[0] - (stop + step) < step // 2:
            stop = grand_truth.shape[0]
        fig = plt.figure(figsize=(12, 6))
        for i in range(len(predictions)):
            plt.plot(predictions[i][pos:stop], '--', label='Model %d' % i)
        plt.plot(grand_truth[pos:stop], '-', label='Grand Truth')
        plt.legend()
        plt.title('Prediction comparison')
        fig.tight_layout()
        # fig.savefig(join(model_path, 'comparison_%s_%d.png' % (t_idx, nbg)))
        # plt.close(fig)
        plt.show()
        pos = stop
        nbg += 1

def create_model(w, c):
    """ Create a keras model
    # Arguments
        :param w: int, time dimension
        :param c: int, channel dimension
    # Returns
        :return: keras model
    """
    l_in = tf.keras.layers.Input(shape=(w, c,))
    lact = l_in
    lact=tf.keras.layers.ZeroPadding1D(1)(lact)
    lact=tf.keras.layers.Conv1D(16,3,activation='relu')(lact)
    lact=tf.keras.layers.ZeroPadding1D(1)(lact)
    lact=tf.keras.layers.Conv1D(16,3,activation='relu')(lact)
    lact=tf.keras.layers.GlobalAveragePooling1D()(lact)
    lact=tf.keras.layers.Dense(1,activation='linear')(lact)
    lact=tf.keras.layers.Dense(w,activation='relu')(lact)

    lact=tf.keras.layers.Dense(1,activation='linear')(lact)

    l_out = lact
    return tf.keras.models.Model(l_in, l_out)

data_file_name = join('resultsSolar.csv')
# data_file_name = join(resultsWind.csv')

w, pred, target = 6, 1, 1
nts, data, idx, t_pos = load_select_standardize(data_file_name, targets,
                                                w=w, pred=pred, chunk=24)
sep_noise = data.shape[1]
data = add_ts(data, nts, 0)     # add month
data = add_ts(data, nts, 2)     # add hour
data = add_ts(data, nts, 3)     # add day of week
name = '%sTar%d_w%dp%d' % ('Solar' if 'resultsSolar.csv' in data_file_name else 'Wind', target, w, pred)

model_name = '%s_NN' % name
train_model(w, pred, model_name, data, idx, t_pos[target],
            epoch=50, lr=1e-3, noise=1e-2, sn=sep_noise, batch=32)
models = [model_name,]
# pred_grap_nn(models, data, idx, t_pos[target], w, pred, t_idx='train')
# pred_grap_nn(models, data, idx, t_pos[target], w, pred, t_idx='valid')
pred_grap_nn(models, data, idx, t_pos[target], w, pred)

!ls

